import{_ as a,c as n,o as t,ae as s}from"./chunks/framework.CBTkueSR.js";const d=JSON.parse('{"title":"利用Spring集成Hibernate","description":"","frontmatter":{},"headers":[],"relativePath":"docs/spring/hibernate.md","filePath":"docs/spring/hibernate.md"}'),r={name:"docs/spring/hibernate.md"};function i(o,e,l,p,c,u){return t(),n("div",null,[...e[0]||(e[0]=[s(`<h1 id="利用spring集成hibernate" tabindex="-1">利用Spring集成Hibernate <a class="header-anchor" href="#利用spring集成hibernate" aria-label="Permalink to &quot;利用Spring集成Hibernate&quot;">​</a></h1><h2 id="_1-hibernate-集成上的特性" tabindex="-1">1. Hibernate 集成上的特性 <a class="header-anchor" href="#_1-hibernate-集成上的特性" aria-label="Permalink to &quot;1. Hibernate 集成上的特性&quot;">​</a></h2><ul><li>RailsNamingStrategy 命名策略</li></ul><p>指定RailsNamingStrategy命名策略，实现类似Rails中的表名、列名命名实现，还添加了基于包名的前缀规则。 例如在META-INF/beangle/table.properties中增加org.beangle.security=security,se_一行。即可实现所有该包下的所有类的表 映射到security用户下的，以se_开头。 采用Rails中的命名样例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>User --&gt; users 类到表</span></span>
<span class="line"><span>User.creator --&gt; creator_id 属性到外建</span></span>
<span class="line"><span>Person --&gt; people 基于英文复数习惯的表</span></span>
<span class="line"><span>Person.roles --&gt; people_resources 关联表</span></span></code></pre></div><ul><li>OverrideConfiguration 支持类重载的覆盖配置</li></ul><p>Hibernate 在XML配置中支持单独指定entity-name,这样可以使用from entity-name这样的hql进行查询。 为了实现实体bean的可扩展性，可以在模型之间的使用接口进行依赖，例如Role的创建者creator可以使用User接口，而不是UserBean对象。 这样带来的问题是，在Role.creator的映射上，需要指定targetEntity指定为UserBean类型，这样又和UserBean耦合了。</p><p>我们的办法是在UserBean上指定entity-name为接口的名称,例如entity-name=&quot;org.beangle.security.blueprint.User&quot; 或者使用@Entity(name=&quot;org.beangle.security.blueprint.User&quot;)注解。这样使用时不用指定targetEntity。 只不过后者hibernate支持较少，需要我们做一些改进。</p><p>如果新的NewUserBean介入系统，即可按照@Entity(name=&quot;org.beangle.security.blueprint.User&quot;)的方式，重新配置在 hibernate的cfg.xml文件中即可。OverrideConfiguration就是支持这一做法的hibernate配置子类。</p><ul><li>新的OpenSessionInViewFilter 推迟打开Session</li></ul><p>通过新实现的OpenSessionInViewFilter过滤器,推迟打开Session，仅在使用时打开，并占用数据库连接。可以在访问login页面、 具有缓存的页面等不是必须使用数据库的场景下，优化对连接使用。</p><ul><li>新的SessionFactoryBean</li></ul><p>新的SessionFactoryBean支持通过Java的方式添加类。模块通过继承AbstractPersistModule，并在jar包中的META-INF/beangle/persist.properties中声明如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>module=com.your.company.webapp.YouPersistModule</span></span>
<span class="line"><span>#hibernate.session_factory_name=jdbc/custom_name(optional)</span></span></code></pre></div><p>此外SessionFactoryBean还支持一个有意思的特性</p><pre><code>1. 从System.properties中设置hibernate.properties，允许从运行参数中的动态设置。
</code></pre><h2 id="_2-支持hibernate的工具" tabindex="-1">2. 支持Hibernate的工具 <a class="header-anchor" href="#_2-支持hibernate的工具" aria-label="Permalink to &quot;2. 支持Hibernate的工具&quot;">​</a></h2><ul><li>HbmGenerator （实验性）</li></ul><p>支持将现有的配置，转换成一体的xml配置。不管现有的配置时纯注解还是混合xml。</p><ul><li>DdlGenerator</li></ul><p>支持指定包生成特定类的ddl语句，包括<strong>注释</strong></p>`,21)])])}const g=a(r,[["render",i]]);export{d as __pageData,g as default};
